#!/bin/bash
#
# cman - Cluster Manager init script
#
# chkconfig: - 21 79
# description: Starts and stops cman
#
#
### BEGIN INIT INFO
# Provides:		cman
# Required-Start:	$network $time
# Required-Stop:	$network $time
# Default-Start:
# Default-Stop:
# Short-Description:	Starts and stops cman
# Description:		Starts and stops the Cluster Manager set of daemons
### END INIT INFO

# set secure PATH
PATH="/bin:/usr/bin:/sbin:/usr/sbin:@SBINDIR@"

local_chkconfig()
{
	ls /etc/rc${2}.d/S*${3} > /dev/null 2>/dev/null
	return $?
}

success()
{
	echo -ne "[  OK  ]\r"
}

failure()
{
	echo -ne "[FAILED]\r"
}

status()
{
	pid=$(pidof $1 2>/dev/null)
	rtrn=$?
	if [ $rtrn -ne 0 ]; then
		echo "$1 is stopped"
	else
		echo "$1 (pid $pid) is running..."
	fi
	return $rtrn
}

# rpm based distros
if [ -d /etc/sysconfig ]; then
	[ -f @INITDDIR@/functions ] && . @INITDDIR@/functions
	[ -f /etc/sysconfig/cluster ] && . /etc/sysconfig/cluster
	[ -f /etc/sysconfig/cman ] && . /etc/sysconfig/cman
	[ -z "$LOCK_FILE" ] && LOCK_FILE="/var/lock/subsys/cman"
fi

# deb based distros
if [ -d /etc/default ]; then
	[ -f /etc/default/cluster ] && . /etc/default/cluster
	[ -f /etc/default/cman ] && . /etc/default/cman
	[ -z "$LOCK_FILE" ] && LOCK_FILE="/var/lock/cman"
	[ -z "$(which chkconfig)" ] && alias chkconfig=local_chkconfig
fi

# CMAN_CLUSTER_TIMEOUT -- amount of time to wait for joinging a cluster
#     before giving up.  If CMAN_CLUSTER_TIMEOUT is positive, then we will
#     wait CMAN_CLUSTER_TIMEOUT seconds before giving up and failing when
#     a cluster is not joined.  If CMAN_CLUSTER_TIMEOUT is zero, then
#     wait indefinately for a cluster join.  If CMAN_CLUSTER_TIMEOUT is
#     negative, do not check to see that the cluster has been joined
[ -z "$CMAN_CLUSTER_TIMEOUT" ] && CMAN_CLUSTER_TIMEOUT=120

# CMAN_QUORUM_TIMEOUT -- amount of time to wait for a quorate cluster on 
#     startup quorum is needed by many other applications, so we may as 
#     well wait here.  If CMAN_QUORUM_TIMEOUT is less than 1, quorum will 
#     be ignored.
[ -z "$CMAN_QUORUM_TIMEOUT" ] && CMAN_QUORUM_TIMEOUT=0

# CMAN_SHUTDOWN_TIMEOUT -- amount of time to wait for cman to become a 
#     cluster member before calling cman_tool leave during shutdown.  
#     The default is 60 seconds
[ -z "$CMAN_SHUTDOWN_TIMEOUT" ] && CMAN_SHUTDOWN_TIMEOUT=60

# CMAN_NOTIFYD_START - control the startup behaviour for cmannotifyd
# the variable can take 3 values:
# yes                   | will always start cmannotifyd
# no                    | will never start cmannotifyd
# conditional (default) | will start cmannotifyd only if scriptlets
#                         are found in @NOTIFYDDIR@
[ -z "$CMAN_NOTIFYD_START" ] && CMAN_NOTIFYD_START=conditional

# FENCE_JOIN_TIMEOUT -- seconds to wait for fence domain join to
#     complete.  If the join hasn't completed in this time, fence_tool join
#     exits with an error, and this script exits with an error.  To wait
#     indefinitely set the value to -1.
[ -z "$FENCE_JOIN_TIMEOUT" ] && FENCE_JOIN_TIMEOUT=20

# NET_RMEM_DEFAULT -- minimum value for rmem_default. If this is set
# higher elsewhere it will not be reduced here.
# These two values are only really needed for the DLM when using sctp
# but do no harm.
[ -z "$NET_RMEM_DEFAULT" ] && NET_RMEM_DEFAULT=4194304

# NET_RMEM_MAX -- minimum value for rmem_max. If this is set
# higher elsewhere it will not be reduced here.
[ -z "$NET_RMEM_MAX" ] && NET_RMEM_MAX=4194304

# FENCED_MEMBER_DELAY -- amount of time to delay fence_tool join to allow
#     all nodes in cluster.conf to become cluster members.  In seconds.
[ -z "$FENCED_MEMBER_DELAY" ] && FENCED_MEMBER_DELAY=45

# FENCE_JOIN -- boolean value used to control whether or not this node
#     should join the fence domain. If FENCE_JOIN is set to "no", then
#     the script will not attempt to the fence domain. If FENCE_JOIN is
#     set to "yes", then the script will attempt to join the fence domain.
#     If FENCE_JOIN is set to any other value, the default behavior is
#     to join the fence domain (equivalent to "yes").
[ -z "$FENCE_JOIN" ] && FENCE_JOIN="yes"

# NETWORK_BRIDGE_SCRIPT -- script to use for xen network bridging.
#     This script must exist in the /etc/xen/scripts directory.
#     The default script is "network-bridge".
[ -z "$NETWORK_BRIDGE_SCRIPT" ] && NETWORK_BRIDGE_SCRIPT="network-bridge"

[ -n "$CLUSTERNAME" ] && cman_join_opts="-c $CLUSTERNAME"

[ -n "$NODENAME" ] && cman_join_opts+=" -n $NODENAME"

# CONFIG_LOADER -- select default config parser.
# This can be:
# xmlconfig       - read directly from cluster.conf and use ricci as default config
#                   propagation method. (default)
# ldapconfig      - read configuration from an ldap server.
#                   Requires: LDAP_URL or/and LDAP_BASEDN envvar to be set.
#                   LDAP_BINDDN and LDAP_BINDPWD have to be either both set or both unset.
# corosync_parser - use internal corosync config file parser.
# openaisparser   - use internal openais config file parser.
[ -n "$CONFIG_LOADER" ] && cman_join_opts+=" -C $CONFIG_LOADER"


### helper/common functions

ok() {
	success
	echo
}

nok() {
	failure
	echo
	exit 1
}

xend_bridged_net_enabled() {
	# Not a xen kernel
	test -d /proc/xen || return 1

	current_runlevel=$(/sbin/runlevel 2>/dev/null | awk '{ print $2 }' 2>/dev/null)
	if [ -z "$current_runlevel" ]; then
		errmsg='Unable to determine the current runlevel'
		return 1
	fi

	if ! chkconfig --levels "$current_runlevel" xend 2>/dev/null; then
		# xend doesn't start at this runlevel.
		return 1
	fi

	if [ ! -f /etc/xen/xend-config.sxp ]; then
		# xend isn't configured to use bridged networking.
		return 1
	fi

	if ! egrep "^[[:blank:]]*\([[:blank:]]*network-script[[:blank:]]+(')?[[:blank:]]*${NETWORK_BRIDGE_SCRIPT}([[:blank:]]*\)|[[:blank:]]+)" /etc/xen/xend-config.sxp >&/dev/null; then
		# xend isn't configured to use bridged networking.
		return 1
	fi
	return 0
}

fence_join_enabled()
{
	#
	# Check the value of FENCE_JOIN.
	# If FENCE_JOIN is set to "no", we will not attempt to join
	# the fence domain. If FENCE_JOIN is set to any other value,
	# we will attempt to join the fence domain (default).
	#
	if [ "$FENCE_JOIN" = "no" ]; then
		return 1
	else
		return 0
	fi
}

fence_xvmd_enabled()
{
	fence_join_enabled || return 1

	#
	# Check for the 'xm' binary.  If it's not here, we are not
	# running on a machine capable of running xvmd.
	#
	which xm > /dev/null 2>&1 || return 1

	#
	# Check for presence of /cluster/fence_xvmd in cluster.conf
	# (If -X is specified, it doesn't matter if it's in cluster.conf;
	#  we'll start it anyway since ccsd is not required)
	#
	if @SBINDIR@/cman_tool status > /dev/null 2>&1; then
		if [ "$FENCE_XVMD_OPTS" = "${FENCE_XVMD_OPTS/-X/}" ]; then
			@SBINDIR@/ccs_tool query /cluster/fence_xvmd || return 1
		fi
	fi

	return 0
}

mtab_configfs()
{
	awk '{ print $2 }' /etc/mtab | \
		grep "/sys/kernel/config" > /dev/null 2>&1 && \
	awk '{ print $3 }' /etc/mtab | \
		grep "configfs" > /dev/null 2>&1
	return $?
}

load_modules()
{
	errmsg=$( /sbin/modprobe configfs 2>&1 ) || return 1
	errmsg=$( /sbin/modprobe dlm 2>&1 ) || return 1
	errmsg=$( /sbin/modprobe lock_dlm 2>&1 ) || true
	return 0
}

start_configfs()
{
	if ! mtab_configfs; then
		errmsg=$( /bin/mount -t configfs none /sys/kernel/config 2>&1 )
		return $?
	fi
	return 0
}

start_cman()
{
	# cman
	if ! @SBINDIR@/cman_tool status > /dev/null 2>&1; then
		case "$CONFIG_LOADER" in
		ldapconfig)
			if [ -n "$LDAP_URL" ] || [ -n "$LDAP_BASEDN" ]; then
				if [ -n "$LDAP_BINDDN" ]; then
					if [ -z "$LDAP_BINDPWD" ]; then
						errmsg="ldadconfig has been select but LDAP_BINDPWD is not set"
						return 1
					fi
				fi
				if [ -n "$LDAP_BINDPWD" ]; then
					if [ -z "$LDAP_BINDDN" ]; then
						errmsg="ldadconfig has been select but LDAP_BINDDN is not set"
						return 1
					fi
				fi
			else
				errmsg="ldadconfig has been select but neither LDAP_URL or LDAP_BASEDN have been set"
				return 1
			fi
		;;
		*)
			# nothing to do for now
		;;
		esac
		errmsg=$( @SBINDIR@/cman_tool -t $CMAN_CLUSTER_TIMEOUT -w join \
			$cman_join_opts 2>&1 ) || return 1

		if [ $CMAN_QUORUM_TIMEOUT -gt 0 ]; then
			errmsg=$( @SBINDIR@/cman_tool -t $CMAN_QUORUM_TIMEOUT \
				-q wait 2>&1 ) || return 1
		fi
	fi
	return 0
}

unfence_self()
{
	echo -n "   Unfencing self... "
	fence_node -U > /dev/null 2>&1

	case $? in
		0)
			ok
		;;
		1)
			nok
		;;
		2)
			echo -n "unconfigured"
			ok
		;;
	esac
	return 0
}

start_qdiskd()
{
	if ! status qdiskd > /dev/null 2>&1 && \
		ccs_tool query /cluster/quorumd >/dev/null 2>&1; then
		errmsg=$( @SBINDIR@/qdiskd -Q 2>&1 ) || return 1
	fi
	return 0
}

start_daemons()
{
	if ! status groupd > /dev/null 2>&1 && \
		[ "$(ccs_tool query /cluster/group/@groupd_compat 2>/dev/null || true)" != "0" ]; then
		errmsg=$( @SBINDIR@/groupd 2>&1 ) || return 1
	fi
	if ! status fenced > /dev/null 2>&1 ; then
		errmsg=$( @SBINDIR@/fenced 2>&1 ) || return 1
	fi
	if ! status dlm_controld > /dev/null 2>&1; then
		errmsg=$( @SBINDIR@/dlm_controld 2>&1 ) || return 1
	fi
	if ! status gfs_controld > /dev/null 2>&1; then
		errmsg=$( @SBINDIR@/gfs_controld 2>&1 ) || return 1
	fi
	if ! status cmannotifyd > /dev/null 2>&1; then
		case "$CMAN_NOTIFYD_START" in
		yes)
			errmsg=$(@SBINDIR@/cmannotifyd 2>&1 ) || return 1
		;;
		no)
			# nothing to do
		;;
		conditional)
			if [ -n "$(ls -1 @NOTIFYDDIR@ 2>/dev/null)" ]; then
				errmsg=$(@SBINDIR@/cmannotifyd 2>&1 ) || return 1
			fi
		;;
		*)
			errmsg="unknown CMAN_NOTIFYD_START option"
			return 1
		;;
		esac
	fi
	return 0
}

start_fence()
{
	if ! @SBINDIR@/cman_tool status | grep Flags | grep 2node > /dev/null 2>&1; then
        	errmsg=$( @SBINDIR@/fence_tool join -w $FENCE_JOIN_TIMEOUT \
			> /dev/null 2>&1 ) || return 1
	else
		errmsg=$( @SBINDIR@/fence_tool join -w $FENCE_JOIN_TIMEOUT \
			-m $FENCED_MEMBER_DELAY join \
			> /dev/null 2>&1 ) || return 1
	fi
	return 0
}

start_fence_xvmd()
{
	if ! status fence_xvmd > /dev/null 2>&1; then
		errmsg=$( @SBINDIR@/fence_xvmd $FENCE_XVMD_OPTS 2>&1 ) || return 1
	fi
	return 0
}

xend_bridged_net_start() {
	if [ ! -x /etc/xen/scripts/${NETWORK_BRIDGE_SCRIPT} ]; then
		if [ -f /etc/xen/scripts/${NETWORK_BRIDGE_SCRIPT} ]; then
			errmsg='The xend bridged network script cannot be run'
		else
			errmsg='The xend bridged network script is missing'
		fi
		return 1
	fi

	/sbin/modprobe netbk >& /dev/null
	/sbin/modprobe netloop >& /dev/null
	bridge_parms=`egrep -m 1 "^[[:blank:]]*\([[:blank:]]*network-script[[:blank:]]+(')?[[:blank:]]*${NETWORK_BRIDGE_SCRIPT}([[:blank:]]*\)|[[:blank:]]+)" /etc/xen/xend-config.sxp| sed -r "s/^[[:blank:]]*\([[:blank:]]*network-script[[:blank:]]+'?[[:blank:]]*${NETWORK_BRIDGE_SCRIPT}[[:blank:]]*//; s/'?[[:blank:]]*\).*//"`
	errmsg=$(/etc/xen/scripts/${NETWORK_BRIDGE_SCRIPT} start $bridge_parms 2>&1) || return 1
	return 0
}

set_networking_params()
{
	if [ ! -f  /proc/sys/net/core/rmem_default ]; then
		return 0;
	fi

	value="$(cat /proc/sys/net/core/rmem_default)"
	if [ $value -le $NET_RMEM_DEFAULT ]; then
		echo $NET_RMEM_DEFAULT > /proc/sys/net/core/rmem_default
	fi

	value="$(cat /proc/sys/net/core/rmem_max)"
	if [ $value -le $NET_RMEM_MAX ]; then
		echo $NET_RMEM_MAX > /proc/sys/net/core/rmem_max
	fi
}

start()
{
	echo "Starting cluster: "

	## global bits
	# guarantee enough limits
	ulimit -c unlimited
	# required for distributions that use tmpfs for /var/run
	mkdir -p /var/run/cluster

	if xend_bridged_net_enabled; then
		echo -n "   Enabling workaround for Xend bridged networking... "
		if xend_bridged_net_start; then
			ok
		else
			nok
		fi
	fi

	echo -n "   Loading modules... "
	if load_modules; then
		ok
	else
		nok
	fi

	echo -n "   Mounting configfs... "
	if start_configfs; then
		ok
	else
		nok
	fi	

	echo -n "   Setting network parameters... "
	if set_networking_params; then
		ok
	else
		nok
	fi

	echo -n "   Starting cman... "
	if start_cman; then
		ok
	else
		nok
	fi

	unfence_self || return 1

	echo -n "   Starting qdiskd... "
	if start_qdiskd; then
		ok
	else
		nok
	fi

	echo -n "   Starting daemons... "
	if start_daemons; then
		ok
	else
		nok
	fi

	if fence_join_enabled; then
		echo -n "   Starting fencing... "
		if start_fence; then
			ok
		else
			nok
		fi
	fi

	if fence_xvmd_enabled; then
		echo -n "   Starting virtual machine fencing host... "
		if start_fence_xvmd; then
			ok
		else
			nok
		fi
	fi
    
	return 0
}

stop_configfs()
{
	if mtab_configfs && [ -z "$(ls -1 /sys/kernel/config)" ]; then
		errmsg=$( /bin/umount /sys/kernel/config 2>&1 )
		if [ $? -ne 0 ]; then
			echo -n $errmsg " "
		fi
	fi
	return 0
}

stop_cman()
{
	if @SBINDIR@/cman_tool status > /dev/null 2>&1; then
		errmsg=$( @SBINDIR@/cman_tool -t $CMAN_SHUTDOWN_TIMEOUT \
			-w leave $1 2>&1 ) || return 1
	fi
	return 0 # all ok
}

stop_daemons()
{
	if status gfs_controld > /dev/null 2>&1; then
		errmsg=$(pkill -TERM gfs_controld) || return 1
	fi
	if status dlm_controld > /dev/null 2>&1; then
		errmsg=$(pkill -TERM dlm_controld) || return 1
	fi
	if status fenced > /dev/null 2>&1; then
		errmsg=$(pkill -TERM fenced) || return 1
	fi
	if status groupd > /dev/null 2>&1; then
		errmsg=$(pkill -TERM groupd) || return 1
	fi
	return 0 # all ok
}

stop_cmannotifyd()
{
	if status cmannotifyd > /dev/null 2>&1; then
		errmsg=$(pkill -TERM cmannotifyd) || return 1
	fi
	return 0
}

stop_qdiskd()
{
	retries=0

	while status qdiskd > /dev/null 2>&1 && [ $retries -lt 5 ]; do
		errmsg=$(pkill -TERM qdiskd) || return 1
		sleep 1
		((retries++))
	done
	if status qdiskd > /dev/null 2>&1; then
		return 1
	fi
	return 0
}

stop_fence()
{
	if status fenced > /dev/null 2>&1; then
		@SBINDIR@/fence_tool leave -w 10 > /dev/null 2>&1
		return $?
	fi
	return 0 # all ok
}

stop_fence_xvmd()
{
	if status fence_xvmd > /dev/null 2>&1; then
		errmsg=$(pkill -TERM fence_xvmd) || return 1
		sleep 1 # A bit of time for fenced to exit
	fi

	status fence_xvmd
	return $?
}

stop()
{
	echo "Stopping cluster: "

	if fence_xvmd_enabled; then
		echo -n "   Stopping virtual machine fencing host... "
		if stop_fence_xvmd; then
			ok
		else
			nok
		fi
	fi

	if fence_join_enabled; then
		echo -n "   Stopping fencing... "
		if stop_fence; then
			ok
		else
			nok
		fi
	fi

	echo -n "   Stopping daemons... "
	if stop_daemons; then
		ok
	else
		nok
	fi

	echo -n "   Stopping the Quorum Disk Daemon: "
	if stop_qdiskd; then
		ok
	else
		nok
	fi

	echo -n "   Stopping cman... "
	if stop_cman "$1"; then
		ok
	else
		nok
	fi

	echo -n "   Stopping cmannotifyd... "
	if stop_cmannotifyd; then
		ok
	else
		nok
	fi

	echo -n "   Unmounting configfs... "
	if stop_configfs; then
		ok
	else
		nok
	fi

	return 0
}

cmanstatus()
{
	if [ "$(ccs_tool query /cluster/group/@groupd_compat 2>/dev/null || true)" != "0" ]; then
		errmsg=$( status groupd 2>&1) || return 1
	fi

	errmsg=$( status fenced 2>&1) || return 1
	errmsg=$( status dlm_controld 2>&1) || return 1
	errmsg=$( status gfs_controld 2>&1) || return 1

	case "$CMAN_NOTIFYD_START" in
	yes)
		errmsg=$( status cmannotifyd 2>&1) || return 1
	;;
	no)
		# nothing to do
	;;
	conditional)
		if [ -n "$(ls -1 @NOTIFYDDIR@ 2>/dev/null)" ]; then
			errmsg=$( status cmannotifyd 2>&1) || return 1
		fi
	;;
	esac

	if ccs_tool query /cluster/quorumd >/dev/null 2>&1; then
		errmsg=$( status qdiskd 2>&1) || return 1
	fi

	errmsg=$( status corosync 2>&1) || return 1

	fence_xvmd_enabled || return 0
	errmsg=$( status fence_xvmd 2>&1) || return 1

	return 0
}

rtrn=0

# See how we were called.
case "$1" in
start)
	if start; then
		touch $LOCK_FILE
	else
		echo $errmsg
		rtrn=1
	fi
;;
stop)
	if stop; then
		rm -f $LOCK_FILE
	else
		echo $errmsg
		rtrn=1
	fi
;;
restart|reload)
	echo -n "Restarting cluster: "
	if stop remove > /dev/null 2>&1 && \
		start > /dev/null 2>&1; then
			ok
	else
		failure
		rtrn=1
	fi
;;
status)
	if cmanstatus; then
		echo "cluster is running."
	else
		echo $errmsg
		rtrn=1
	fi
;;
*)
	echo "Usage: $0 {start|stop|reload|restart|status}"
	rtrn=1
;;
esac

exit $rtrn
